# 4. 存储器管理

## 4.1 存储器的层次结构

### 4.1.1 多层结构的存储器系统

**1. 存储器的多层结构**

![201904181](img\201904181.png)

> 寄存器，高速缓存，主存，磁盘缓存属于操作系统的管辖范围，掉电后存储的信息将不再存在。
>
> 固定磁盘和可移动存储介质中存储的信息会被长期的保存。

**2. 可执行存储器**

寄存器和主存储器被称为可执行存储器。

> os主要提供对可执行存储器的分配、回收、以及存储层次间数据的移动等。
>
> 用户主要负责对设备和文件的管理

## 4.2 程序的装入和链接

> **将用户源程序变为可在内存中执行的程序的步骤：**
>
> 1. 编译：由编译程序将用户源代码编译成若干个目标模块
>
> 2. 链接：由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块
>
> 3. 装入：由装入程序将装入模块装入内存

示意图：

![201904182](img\201904182.png)

### 4.2.1程序的装入

背景：将单个目标模块装入内存时的三种装入方式

需要注意的是程序中的逻辑地址和在内存中的物理地址的关系。

**1. 绝对装入方式**

**内容：**装入模块装入内存后，程序中的逻辑地址与实际内存地址完全相同，不须对程序和数据的地址进行修改。程序中所使用的绝对地址，可在编译或汇编时给出，也可由程序员赋予。通常在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。

**注意：**仅适用于单道程序的运行环境。

**2. 可重定位装入方式**

**产生的原因：**上述的绝对装入方式只能将程序装入到内存的指定位置，只适合单道程序的运行环境，不适用于多道程序的处理环境。

**原理：**为了克服上述的缺点，在多道程序环境下，目标模块的起始地址（逻辑地址）通常从0开始，程序中的其他地址都是相对于起始地址计算的。因此应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。

装入时，会对目标程序中指令和数据的地址（逻辑地址）进行修改（修改为物理地址），修改的过程称为重定位。由于修改的过程是在装入时一次完成，以后不可改变，因此又被称为**静态重定位**。

**示意图：**

![201904183](img\201904183.png)

**缺点：**不允许程序在内存中进行移动

**3. 动态运行时装入方式**

**产生的原因：**克服程序在内存中无法移动的缺点。

**原理：**可重定位的装入方式，程序装入内存之后便无法进行移动。但在实际上，在运行过程中程序在内存中的位置可能经常要改变。动态运行时的装入程序，在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种**地址转换推迟到程序真正要执行时才进行**。因此，装入内存后的所有地址都仍是**逻辑地址**。为使地址转换不影响指令的执行速度，应设置一个**重定位寄存器**。

### 4.2.3 程序的链接

背景：程序经过编译后得到一组目标模块，再利用链接程序将目标模块链接，形成装入模块。根据链接时间的不同，把链接分成三种：

**1. 静态链接方式**

**原理：**

在程序运行前，将目标模块及所需的库函数链接成一个完整的装配模块（也叫做可执行文件），以后不再拆开。这种方式称为静态链接方式。

将目标模块装配成装入模块时需解决的两个问题：

1. 对相对地址进行修改：将模块A,B,C连成一个模块的时候，原模块B和模块C的起始地址不再是0，分别变为L和（L + M），所以需要对B和C中的相对地址进行修改。

2. 变换外部调用符号：外部调用符号即下方的Call B和Call C中的B和C，在将多个模块连接成一个的时候，所有模块的相对地址均已经发生变化，所以需要对外部调用符号也进行相应的变化。

**示意图：**

![201904184](img\201904184.png)

**2. 装入时动态链接**

**产生的原因：**克服静态链接方式的缺点：1）不便于修改和更新；2）无法实现对目标模块的共享。

**原理：**用户源程序经编译后所得的目标模块，是在装入内存时，边装入边链接的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要修改目标模块中的相对地址（修改的方式同上）。

**优点：**

1. 便于修改和更新：各目标模块分开存放，便于修改，在装入内存的时候才进行连接。
2. 便于实现对目标模块的共享：静态链接方式中，每个应用模块均必须含有对目标模块的拷贝，无法实现共享。采用装入时动态链接，只需要装入时，将目标模块连接到应用模块上即可。

缺点：

1. 盲目的将目标模块装入内存，效率低。

**3. 运行时动态链接**

**产生的原因：**克服装入时动态链接的缺点（盲目地将可能会用到的模块全部装入内存），提高效率。

**原理：**运行时动态链接是将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上。凡执行过程中未被用到的目标模块，不会调入内存和链接，这样不仅加快程序的装入过程，而且节省大量的内存空间。

## 4.3 连续分配存储管理方式

为了将用户程序装入内存，需要在内存中为用户程序分配一定大小的内存空间。连续分配方式是为一个用户程序分配一个**连续**的内存空间，主要分为：单一连续分配，固定分区分配，动态分区分配，可重定位分区分配

### 4.3.1单一连续分配

**1. 概述**

最简单的一种存储管理方式，但只能用于**单用户、单任务**的操作系统中。

采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常放在内存低址部分，用户区是指除系统区以外的全部内存空间，提供给用户使用。

**2. 缺点**

内存中仅装有一道用户程序，内存空间由该用户程序独占。

### 4.3.2 固定分区分配

**1. 产生的原因**

单一连续分区分配方式仅适用于当用户单任务的操作系统中，效率低下，浪费资源

**2. 原理**

​	将内存用户空间划分为若干个**固定大小的区域**（可以相等也可以不相等），在每个分区中只装入一道作业，这样把用户空间划分为几个分区，便允许有几道作业**并发执行**。当有一空闲分区时，便可以再从外存的后备作业队列中，选择一个适当大小的作业装入该分区，当该作业结束时，可再从后备作业队列中找出另一作业调入该分区。

**3. 两种划分分区的方法**

1）分区大小相等：缺乏灵活性，并且**容易产生大量的内碎片**，造成资源的浪费。常用于一台计算机控制多个相同对象的场合。

2）分区大小不等：把内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区，可根据程序的大小为之分配适当的分区。

**4. 内存分配的实现方式**

​	为便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)。

​       当有一用户程序要装入时，由内存分配程序检索该表，从中找出一个能满足要求的、尚未分配的分区，将之分配给该程序，然后将该表项中的状态置为“已分配”；若未找到大小足够的分区，则拒绝为该用户程序分配内存。

**示意图：**

![20190419](img\20190419.png)

**5. 缺点**

容易产生大量的内碎片，造成资源的浪费。

> 内碎片：由于作业容量和分区容量不完全相符而产生的空间碎片。
>
> 外碎片：由于大量的信息先后写入，删除，置换而形成的空间碎片。

### 4.3.3 动态分区分配

**1. 产生的原因**

主要是想解决固定分区分配方式中会产生大量的内碎片的问题。

**2. 原理**

动态分区分配是根据进程的实际需要，动态地为之分配内存空间。作业装入内存时，把可用内存分出一个连续区域给作业，且分区的大小正好适合作业大小的需要。分区的大小和个数依装入作业的需要而定。

#### 4.3.3.1 在实现的过程中需要解决的三个问题

1. 分区分配中的数据结构

2. 分区分配算法

3. 分区分配及回收操作

**1. 涉及到的数据结构**

对于空闲分区：使用空闲分区表或者空闲分区链

对于已占分区：使用已占分区表

具体数据结构的格式见课本137页。

**2. 动态分区分配算法**

主要的目的：从空闲分区表或空闲分区链中选出一分区分配给该作业。主要算法有三种：首次适应算法，循环首次适应算法，最佳首次适应算法

具体的算法见下文：[点击](#4332分区分配算法)

**3. 分区分配操作**

主要操作是对内存进行回收和分配。

**1）分配内存**

核心流程：

![201904193](img\201904193.png)

> 一些数据的解释
>
> m.size：每个空闲分区的大小
>
> u.size：请求分区的大小
>
> size：系统设置的阈值

**2）回收内存**

根据回收区的首地址在空闲分区表中找到相应的插入点，进行回收，会出现以下四种情况：

(1) 回收区与插入点的前一个分区F1邻接：将回收区与F1合并，修改F1的表项的分区大小

(2) 回收区与插入点的后一个分区F2邻接：将回收区与F2合并，修改F2的表项的首址、分区大小

(3) 回收区与插入点的前后两个分区F1、F2邻接：将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和

(4) 回收区既不与F1邻接，又不与F2邻接：为回收区单独建立新表项，填写回收区的首址与大小，根据其首址插到空闲链中的适当位置

示意图如下：

![201904195](img\201904195.png)

#### 4.3.3.2 分区分配算法

**1. 首次适应算法**

​	FF算法要求空闲分区表以地址递增的次序排列。在分配内存时，从表首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲分区表中。若从头到尾不存在满足要求的分区，则分配失败。

**优点：**优先利用内存低址部分的内存空间

**缺点：**低址部分不断划分，产生小碎片（内存碎块、内存碎片、零        头）；每次查找从低址部分开始，增加了查找的开销

**2. 循环首次适应算法**

​	在分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直到找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。需要设置一个查询指针，记录上一次查找到的位置。

**优点：**使内存空闲分区分布均匀，减少查找的开销

**缺点：**破坏了大的空闲分区

**3. 最佳适应算法**

每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。要求将所有的空闲分区按其容量以**从小到大**的顺序形成一空闲分区链。

**优点：**避免了大材小用

**缺点：**产生许多难以利用的小空闲区

### 4.3.4 动态可重定位分区分配

**1. 产生的原因**

​	在连续分配方式中，必须把系统或用户程序装入一连续的内存空间。如果在统统中只有若干个小分区，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻，所以无法将程序装入内存。

**2. 解决办法**

​	将内存中的所有作业进行移动，使它们全部邻接，这样可把原来分散的小分区拼接成大分区，这种方法称为“拼接”或“紧凑”。

注意：若想实现需要借助重定位寄存器， ————>与上边的动态运行时装入方式相适应

**3. 实现方式**

​	在动态运行时装入的方式时，将相对地址转换为物理地址的工作在程序指令真正要执行时才进行。地址转换需要重定位寄存器的支持。程序执行时访问的内存地址是相对地址与重定位寄存器中的地址相加而成。

**示意图：**

![201904196](img\201904196.png)

**4. 算法执行的具体流程图**

![201904197](img\201904197.png)

## 4.4 对换

## 4.5 分页存储管理方式

## 4.6 分段存储管理方式